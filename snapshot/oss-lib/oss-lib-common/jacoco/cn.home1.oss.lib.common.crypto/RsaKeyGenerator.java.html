<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RsaKeyGenerator.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">oss-lib-common</a> &gt; <a href="index.source.html" class="el_package">cn.home1.oss.lib.common.crypto</a> &gt; <span class="el_source">RsaKeyGenerator.java</span></div><h1>RsaKeyGenerator.java</h1><pre class="source lang-java linenums">package cn.home1.oss.lib.common.crypto;

import static com.google.common.base.Preconditions.checkArgument;

import com.google.common.base.Preconditions;

import lombok.Getter;
import lombok.SneakyThrows;
import lombok.extern.slf4j.Slf4j;

import org.bouncycastle.asn1.ASN1Encodable;
import org.bouncycastle.asn1.ASN1Primitive;
import org.bouncycastle.asn1.pkcs.PrivateKeyInfo;
import org.bouncycastle.asn1.x509.SubjectPublicKeyInfo;
import org.bouncycastle.util.io.pem.PemObject;
import org.bouncycastle.util.io.pem.PemWriter;

import java.io.StringWriter;
import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.Provider;
import java.security.SecureRandom;

import cn.home1.oss.lib.common.CodecUtils;
import cn.home1.oss.lib.common.StringUtils;

/**
 * Created by zhanghaolun on 16/11/4.
 */
<span class="fc" id="L30">@Slf4j</span>
public class RsaKeyGenerator implements KeyGenerator {

  private final Provider provider;
<span class="nc" id="L34">  @Getter</span>
  private final String spec;
<span class="nc" id="L36">  @Getter</span>
  private final String keyFormat;
<span class="nc" id="L38">  @Getter</span>
  private final int keySize;
<span class="nc" id="L40">  @Getter</span>
  private final String keyType;
  private RsaKey key;

<span class="fc" id="L44">  public RsaKeyGenerator(final String spec) {</span>
<span class="fc" id="L45">    this.provider = Cryptos.provider();</span>
<span class="fc" id="L46">    this.spec = spec;</span>
<span class="fc" id="L47">    this.keyFormat = RsaKey.keyFormat(spec);</span>
<span class="fc" id="L48">    this.keySize = RsaKey.keySize(spec);</span>
<span class="fc" id="L49">    this.keyType = RsaKey.keyType(spec);</span>
<span class="fc" id="L50">    Preconditions.checkArgument(RsaKey.SUPPORTED_PAIR_FORMATS.contains(this.keyFormat), &quot;keyFormat &quot; + this.keyFormat + &quot; not supported.&quot;);</span>
<span class="fc" id="L51">    Preconditions.checkArgument(RsaKey.KEY_TYPE_PAIR.equals(this.keyType), &quot;keyType &quot; + this.keyType + &quot; not supported.&quot;);</span>
<span class="fc" id="L52">  }</span>

  @Override
  public KeyExpression generateKey() {
<span class="fc" id="L56">    final KeyExpression keyExpression = RsaKeyGenerator.generateRsaKeyPair( //</span>
      this.provider, this.keyFormat, this.keySize);
<span class="fc" id="L58">    this.key = new RsaKey(keyExpression);</span>
<span class="fc" id="L59">    return this.key.getKeyExpression();</span>
  }

  @Override
  public KeyExpression getKey(final String spec) {
<span class="nc bnc" id="L64" title="All 2 branches missed.">    if (this.key == null) {</span>
<span class="nc" id="L65">      this.generateKey();</span>
    }

<span class="nc" id="L68">    return this.key.getKey(spec);</span>
  }

  public static KeyExpression convertPairFromPkcs8X509ToPkcs1(final KeyExpression pairPkcs8X509) {
<span class="fc" id="L72">    checkArgument(RsaKey.KEY_FORMAT_PKCS8_X509.equals(RsaKey.keyFormat(pairPkcs8X509.getSpec())), //</span>
<span class="fc" id="L73">      &quot;unsupported spec&quot; + pairPkcs8X509.getSpec());</span>
<span class="fc" id="L74">    final byte[] privateKeyPkcs8 = CodecUtils.decodeBase64(RsaKey.extractPrivateKey(pairPkcs8X509));</span>
<span class="fc" id="L75">    final byte[] publicKeyX509 = CodecUtils.decodeBase64(RsaKey.extractPublicKey(pairPkcs8X509));</span>
<span class="fc" id="L76">    final String privateKeyPem = convertPrivateKeyFromPkcs8ToPkcs1Pem(privateKeyPkcs8);</span>
<span class="fc" id="L77">    final String publicKeyPem = convertPublicKeyFromX509ToPkcs1Pem(publicKeyX509);</span>

<span class="fc" id="L79">    final int keySize = RsaKey.keySize(pairPkcs8X509.getSpec());</span>
<span class="fc" id="L80">    final String spec = RsaKey.keySpec(RsaKey.KEY_FORMAT_PKCS1 + CryptoConstants.UNDERSCORE + RsaKey.KEY_FORMAT_PKCS1, keySize, RsaKey.KEY_TYPE_PAIR);</span>
<span class="fc" id="L81">    final String value = StringUtils.dropComment(privateKeyPem, RsaKey.COMMENT_MARK) + CryptoConstants.COLON + StringUtils.dropComment(publicKeyPem, RsaKey.COMMENT_MARK);</span>
<span class="fc" id="L82">    return new KeyExpression(spec, value);</span>
  }

<span class="nc" id="L85">  @SneakyThrows</span>
  public static String convertPrivateKeyFromPkcs8ToPkcs1Pem(final byte[] privateKeyPkcs8) {
    // Convert private key from PKCS8 to PKCS1:
<span class="fc" id="L88">    final ASN1Encodable encodable = PrivateKeyInfo.getInstance(privateKeyPkcs8).parsePrivateKey();</span>
<span class="fc" id="L89">    return pem(encodable.toASN1Primitive().getEncoded(), RsaKey.KEY_FORMAT_PKCS1, RsaKey.KEY_TYPE_PRIVATE);</span>
  }

<span class="nc" id="L92">  @SneakyThrows</span>
  public static String convertPublicKeyFromX509ToPkcs1Pem(final byte[] publicKeyX509) {
    // Convert public key from X.509 SubjectPublicKeyInfo to PKCS1:
<span class="fc" id="L95">    final ASN1Primitive publicKeyPrimitive = SubjectPublicKeyInfo.getInstance(publicKeyX509).parsePublicKey();</span>
<span class="fc" id="L96">    return pem(publicKeyPrimitive.getEncoded(), RsaKey.KEY_FORMAT_PKCS1, RsaKey.KEY_TYPE_PUBLIC);</span>
  }

  public static KeyExpression generateRsaKeyPair( //
    final Provider provider, final String keyFormat, final int keySize //
  ) {
<span class="fc" id="L102">    final String privateKeyFormat = keyFormat.split(CryptoConstants.UNDERSCORE)[0];</span>
<span class="fc" id="L103">    final String publicKeyFormat = keyFormat.split(CryptoConstants.UNDERSCORE)[1];</span>

<span class="fc" id="L105">    final KeyExpression pairPkcs8X509 = generateRsaKeyPairPkcs8X509(provider, keySize);</span>
<span class="fc" id="L106">    final KeyExpression pairPkcs1 = convertPairFromPkcs8X509ToPkcs1(pairPkcs8X509);</span>

    final String privateKey;
<span class="pc bpc" id="L109" title="1 of 2 branches missed.">    if (RsaKey.KEY_FORMAT_PKCS8.equals(privateKeyFormat)) {</span>
<span class="nc" id="L110">      privateKey = RsaKey.extractPrivateKey(pairPkcs8X509);</span>
<span class="pc bpc" id="L111" title="1 of 2 branches missed.">    } else if (RsaKey.KEY_FORMAT_PKCS1.equals(privateKeyFormat)) {</span>
<span class="fc" id="L112">      privateKey = RsaKey.extractPrivateKey(pairPkcs1);</span>
    } else {
<span class="nc" id="L114">      throw new IllegalArgumentException(&quot;unsupported privateKeyFormat &quot; + privateKeyFormat);</span>
    }

    final String publicKey;
<span class="pc bpc" id="L118" title="1 of 2 branches missed.">    if (RsaKey.KEY_FORMAT_X509.equals(publicKeyFormat)) {</span>
<span class="fc" id="L119">      publicKey = RsaKey.extractPublicKey(pairPkcs8X509);</span>
<span class="nc bnc" id="L120" title="All 2 branches missed.">    } else if (RsaKey.KEY_FORMAT_PKCS1.equals(publicKeyFormat)) {</span>
<span class="nc" id="L121">      publicKey = RsaKey.extractPublicKey(pairPkcs1);</span>
    } else {
<span class="nc" id="L123">      throw new IllegalArgumentException(&quot;unsupported publicKeyFormat &quot; + publicKeyFormat);</span>
    }

<span class="fc" id="L126">    final String spec = RsaKey.keySpec(privateKeyFormat + CryptoConstants.UNDERSCORE + publicKeyFormat, keySize, RsaKey.KEY_TYPE_PAIR);</span>
<span class="fc" id="L127">    final String value = privateKey + CryptoConstants.COLON + publicKey;</span>
<span class="fc" id="L128">    return new KeyExpression(spec, value);</span>
  }

<span class="nc" id="L131">  @SneakyThrows</span>
  public static KeyPair generateRsaKeyPair(final Provider provider, final int keySize) {
<span class="fc" id="L133">    final KeyPairGenerator keyPairGen = KeyPairGenerator.getInstance(CryptoConstants.ALGO_RSA, provider);</span>
    // final byte[] seed = DateFormatUtils.format(currentTimeMillis(), &quot;yyyyMMdd&quot;).getBytes();
<span class="fc" id="L135">    keyPairGen.initialize(keySize, new SecureRandom());</span>
    //keygen.initialize(keySize);
<span class="fc" id="L137">    return keyPairGen.generateKeyPair();</span>
  }

<span class="nc" id="L140">  @SneakyThrows</span>
  public static KeyExpression generateRsaKeyPairPkcs8X509(
    final Provider provider, //
    final int keySize //
  ) {
<span class="fc" id="L145">    final KeyPair pairPkcs8X509 = generateRsaKeyPair(provider, keySize);</span>
<span class="fc" id="L146">    final byte[] privateKeyPkcs8 = pairPkcs8X509.getPrivate().getEncoded();</span>
<span class="fc" id="L147">    final byte[] publicKeyX509 = pairPkcs8X509.getPublic().getEncoded();</span>

<span class="fc" id="L149">    final String privateKeyPem = pem(privateKeyPkcs8, RsaKey.KEY_FORMAT_PKCS8, RsaKey.KEY_TYPE_PRIVATE);</span>
<span class="fc" id="L150">    final String publicKeyPem = pem(publicKeyX509, RsaKey.KEY_FORMAT_X509, RsaKey.KEY_TYPE_PUBLIC);</span>

<span class="fc" id="L152">    final String spec = RsaKey.keySpec(RsaKey.KEY_FORMAT_PKCS8 + CryptoConstants.UNDERSCORE + RsaKey.KEY_FORMAT_X509, keySize, RsaKey.KEY_TYPE_PAIR);</span>
<span class="fc" id="L153">    final String value = StringUtils.dropComment(privateKeyPem, RsaKey.COMMENT_MARK) + CryptoConstants.COLON + StringUtils.dropComment(publicKeyPem, RsaKey.COMMENT_MARK);</span>
<span class="fc" id="L154">    return new KeyExpression(spec, value);</span>
  }

<span class="nc" id="L157">  @SneakyThrows</span>
  public static String pem(final byte[] bytes, final String keyFormat, final String keyType) {
    final String type;
<span class="fc bfc" id="L160" title="All 2 branches covered.">    if (RsaKey.KEY_TYPE_PRIVATE.equals(keyType)) {</span>
<span class="fc" id="L161">      type = &quot;RSA PRIVATE KEY&quot;;</span>
<span class="pc bpc" id="L162" title="1 of 2 branches missed.">    } else if (RsaKey.KEY_TYPE_PUBLIC.equals(keyType)) {</span>
<span class="fc bfc" id="L163" title="All 2 branches covered.">      if (RsaKey.KEY_FORMAT_X509.equals(keyFormat)) {</span>
<span class="fc" id="L164">        type = &quot;PUBLIC KEY&quot;;</span>
      } else {
<span class="fc" id="L166">        type = &quot;RSA PUBLIC KEY&quot;;</span>
      }
    } else {
<span class="nc" id="L169">      throw new IllegalArgumentException(&quot;unsupported keyType &quot; + keyType);</span>
    }

<span class="fc" id="L172">    final StringWriter stringWriter = new StringWriter();</span>
<span class="pc" id="L173">    try (final PemWriter pemWriter = new PemWriter(stringWriter)) {</span>
<span class="fc" id="L174">      pemWriter.writeObject(new PemObject(type, bytes));</span>
<span class="pc bpc" id="L175" title="6 of 8 branches missed.">    }</span>
<span class="fc" id="L176">    return stringWriter.toString();</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.7.201606060606</span></div></body></html>